Ext.data.JsonP.command_compiler({"guide":"<h1>Sencha Compiler Reference</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/command_compiler-section-1'>Sets And The Current Set</a></li>\n<li><a href='#!/guide/command_compiler-section-2'>Generating Output with concat</a></li>\n<li><a href='#!/guide/command_compiler-section-3'>Saving And Restoring Sets</a></li>\n<li><a href='#!/guide/command_compiler-section-4'>Set Operations</a></li>\n<li><a href='#!/guide/command_compiler-section-5'>Compiler Directives</a></li>\n<li><a href='#!/guide/command_compiler-section-6'>Conditional Compilation</a></li>\n</ol>\n</div>\n\n<p>One of the major components new to V3 of Sencha Cmd is the compiler. In a nutshell, the\ncompiler is a JavaScript-to-JavaScript, framework-aware optimizer. It is designed to\n\"understand\" your high-level, Ext JS and Sencha Touch code and produce the smallest, most\nefficient code possible to support these high-level abstractions.</p>\n\n<p><p><img src=\"guides/command_compiler/../command/sencha-command-128.png\" alt=\"\"></p></p>\n\n<p>Before digging in to the depths of the compiler, it is a good idea to read up on the most\ncommon use cases described in these guides:</p>\n\n<ul>\n<li><a href=\"#/guide/command_app\">Using Sencha Cmd with Ext JS</a></li>\n<li><a href=\"#/guide/command_app_single\">Single-Page Ext JS Apps</a></li>\n<li><a href=\"#/guide/command_app_multi\">Multi-Page Ext JS Apps</a></li>\n</ul>\n\n\n<p>With this basic understanding, the details below should help flesh out the possibilities.</p>\n\n<p>In the above guides, the compiler's <code>page</code> command played a key role. This command is not\nrequired, and so the majority of this reference focuses on using the compiler is a more\nmanual way without the <code>page</code> command.</p>\n\n<p>While this shift of focus is important to explain the compiler, keep in mind that it is\n<strong>highly recommended</strong> that you use the <code>page</code> command whenever possible. The <code>page</code> command\npresents the compiler with the best vantage point on the code it is compiling, gives it\nthe most flexibility for future optimizations and also reduces repetition of code or page\ncontent on the command line.</p>\n\n<h2 id='command_compiler-section-1'>Sets And The Current Set</h2>\n\n<p>The compiler manages a set of source files and analyzes these files to determine their\ndependencies. The set of all files is determined by the \"classpath\":</p>\n\n<pre><code>sencha compile -classpath=sdk/src,app ...\n</code></pre>\n\n<p>In this example, the compiler recursively loads \"*.js\" from the specified list of folders.\nThis set of all files defines the basis for all operations to follow (i.e., it defines the\n\"universe\").</p>\n\n<p>The compiler's output commands (e.g., <code>concat</code> and <code>metadata</code>) operate on the set of files\ncalled the \"current set\". The current set starts out equal to the universe of all files,\nbut this can be manipulated using the many commands provided to perform set operations.</p>\n\n<p>NOTE: With the compiler, you will often see rather long command lines using the command\nchaining mechanism \"and\". Also, in practical use cases, once command lines start to get\nvery long, you will probably want to consider using <a href=\"#/guide/command_ant\">Ant</a> or a\n\"response file\". See <a href=\"#/guide/command_advanced\">Advanced Sencha Cmd</a>. In this guide,\nall command lines will be complete (and potentially long) to keep the examples as clear\nas possible.</p>\n\n<h2 id='command_compiler-section-2'>Generating Output with concat</h2>\n\n<p>A compiler ultimately is all about writing useful output given some number of inputs. The\n<code>concat</code> command is designed to concatenate the source for the current set of files in the\nappropriate dependency order.</p>\n\n<p>The one required parameter is <code>-out</code> which indicates the name of the output file. There are\nother options, however, that effect the generated file. You can pick one of the following\noptions for compression:</p>\n\n<ul>\n<li><code>-compress</code> - Compress the generated file using the default compressor. Currently this\nis the same as <code>-yui</code>.</li>\n<li><code>-max</code> - Compress the generated file using all compressors and keep the smallest.</li>\n<li><code>-closure</code> - Compress the generated file using <a href=\"https://developers.google.com/closure/compiler/\">Google Closure Compiler</a>.</li>\n<li><code>-uglify</code> - Compress the generated file using <a href=\"https://github.com/mishoo/UglifyJS/\">UglifyJS</a>.</li>\n<li><code>-yui</code> - Compress the source file using  <a href=\"http://developer.yahoo.com/yui/compressor/\">YUI Compressor</a>.</li>\n<li><code>-strip</code> - Strip comments from the output file, but preserve whitespace. This is the\noption used to convert <code>ext-all-debug-w-comments.js</code> into <code>ext-all-debug.js</code>.</li>\n</ul>\n\n\n<p>The following command illustrates how to produce three flavors of output given a single\nread of the source.</p>\n\n<pre><code>sencha compile -classpath=sdk/src \\\n    exclude -namespace Ext.chart and \\\n    concat ext-all-nocharts-debug-w-comments.js and \\\n    -debug=true -strip \\\n    concat ext-all-nocharts-debug.js and \\\n    -debug=false -yui \\\n    concat ext-all-nocharts.js\n</code></pre>\n\n<h3>Generating Metadata</h3>\n\n<p>The compiler can also generate metadata in many useful ways. For example, the names of all\nsource files, the set of files in dependency order, etc.. To see what is available, check\nout <a href=\"#/guide/command_compiler_meta\">Generating Metadata</a>.</p>\n\n<h2 id='command_compiler-section-3'>Saving And Restoring Sets</h2>\n\n<p>As you find the need to produce multiple output files, it can be very helpful to save the\ncurrent set for later use.</p>\n\n<pre><code>sencha compile -classpath=sdk/src \\\n    exclude -namespace Ext.chart and \\\n    save nocharts and \\\n    ...\n    restore nocharts and \\\n    ...\n</code></pre>\n\n<p>The <code>save</code> command simply takes a snapshot of the current set and stores it under the given\nname (\"nocharts\" in the above).</p>\n\n<p>The simplest use of a saved set is the <code>restore</code> command. This does the reverse and restores\nthe current set to its state at the time of the <code>save</code>.</p>\n\n<h2 id='command_compiler-section-4'>Set Operations</h2>\n\n<p>Many of the commands provided by the compiler are classified as \"set operations\". That is,\noperations that work on and produce sets. In the case of the compiler, sets of files or\nclasses.</p>\n\n<p>Before diving into the details of these commands, a quick primer on set terminology will\nbe helpful.</p>\n\n<h3>A Little Set Theory</h3>\n\n<p>There are three classic set operations:</p>\n\n<ul>\n<li><p>Intersection - The intersection of two sets is a set containing only what was in both\nsets.\n<p><img src=\"guides/command_compiler/set-intersect.png\" alt=\"\"></p></p></li>\n<li><p>Union - The union of two sets is a set containing whatever was in either of the sets.\n<p><img src=\"guides/command_compiler/set-union.png\" alt=\"\"></p></p></li>\n<li><p>Difference - The difference of two sets is the set of all things in the first set that\nare not in the second set.\n<p><img src=\"guides/command_compiler/set-difference.png\" alt=\"\"></p></p></li>\n</ul>\n\n\n<h3>Set <code>include</code> and <code>exclude</code></h3>\n\n<p>These two set operations are probably the most common (and flexible) set operations. Both\nsupport these basic switches:</p>\n\n<ul>\n<li><code>-namespace</code> - Matches files that define types in the specified namespace.</li>\n<li><code>-class</code> - Matches a specific defined type.</li>\n<li><code>-file</code> - Matches filenames and/or folder names using Ant-style glob patterns (a \"*\"\nmatches only filename characters, where \"**\" matches folders).</li>\n<li><code>-tag</code> - Matches any files with the specified tag(s) (see below).</li>\n<li><code>-set</code> - The files that are present in any of the specified named sets.</li>\n</ul>\n\n\n<p>In all of these cases, the next command line argument is a comma-separate list of match\ncriteria. Also, a single <code>exclude</code> or <code>include</code> can have as many switch/value pairs as\nneeded.</p>\n\n<p>So, let's start with a simple example and build an \"ext-all-no-charts-debug-w-comments.js\".</p>\n\n<pre><code>sencha compile -classpath=sdk/src \\\n    exclude -namespace Ext.chart and \\\n    ...\n</code></pre>\n\n<p>What is happening here is that we started with only the Ext JS sources (in sdk/src) and\nthey were all part of the \"current set\". We then performed a set difference by excluding\nall files in the \"Ext.chart\" namespace. The current set was then equivalent to \"ext-all\"\nbut without any of the Chart package.</p>\n\n<h3>Negating <code>include</code> and <code>exclude</code> with <code>-not</code></h3>\n\n<p>Both <code>include</code> and <code>exclude</code> support a rich set of matching criteria. To round this out,\nthere is also the <code>-not</code> switch. This switch negate the matching criteria that follows it\nsuch that the files included or excluded will be all those that do not match the criteria.</p>\n\n<p>For example:</p>\n\n<pre><code>sencha compile -classpath=sdk/src,js \\\n    ... \\\n    exclude -not -namespace Ext and \\\n    ...\n</code></pre>\n\n<p>The above <code>exclude</code> command will exclude from the current set any classes that are not in\nthe \"Ext\" namespace.</p>\n\n<h3>The <code>all</code> Set</h3>\n\n<p>In some cases, it is very handy to restore the current set to all files or to the empty set.\nTo do this, you simply use <code>include</code> or <code>exclude</code> with the <code>-all</code> switch. To build on the\nprevious example:</p>\n\n<pre><code>sencha compile -classpath=sdk/src \\\n    ... \\\n    include -all and \\\n    ... \\\n    exclude -all and \\\n    ...\n</code></pre>\n\n<p>After the <code>include -all</code>, the current set is all files. After <code>exclude -all</code> it is the\nempty set.</p>\n\n<h3>Union</h3>\n\n<p>As you have seen, the <code>include</code> command is a form of set union: it performs a union of the\ncurrent set with the set of matching files. Sometimes it is desirable to not include the\ncurrent set in the union and only those file matching the desired criteria. This is what\nthe <code>union</code> command does.</p>\n\n<p>The <code>union</code> command has all of the options of <code>include</code>. In fact, this <code>union</code> command:</p>\n\n<pre><code>sencha compile -classpath=sdk/src ... and \\\n    union -namespace Ext.grid,Ext.chart and \\\n    ...\n</code></pre>\n\n<p>Is exactly equivalent to this pair of <code>exclude</code> and <code>include</code> commands:</p>\n\n<pre><code>sencha compile -classpath=sdk/src ... and \\\n    exclude -all and \\\n    include -namespace Ext.grid,Ext.chart and \\\n    ...\n</code></pre>\n\n<h3>Transitivity / Recursive Union</h3>\n\n<p>One of the most important set operations is the union of all files explicitly specified\nand all of the files they require. And also the files they require, etc.. This is the core\nof a build process since this is how you select only the set of files you need. So, if you\nhave a small set of top-level files to start the process, say the class <code>MyApp.App</code>, you\ncan do something like this:</p>\n\n<pre><code>sencha compile -classpath=sdk/src,app \\\n    union -r -class MyApp.App and \\\n    ...\n</code></pre>\n\n<p>The <code>union</code> command starts with no current set, includes only the class <code>MyApp.App</code> and\nthen proceeds to include all the things it needs recursively. The resulting current set\nis all files needed by the application.</p>\n\n<h3>Intersect (Strict)</h3>\n\n<p>The <code>intersect</code> command is a bit less flexible in the criteria it supports: it only accepts\nnamed sets (using <code>-set</code>).</p>\n\n<pre><code>sencha compile -classpath=sdk/src,common,page1/src,page2/src \\\n    ... \\\n    intersect -set page1,page2 and \\\n    ... \\\n</code></pre>\n\n<p>This command above intersects the two page sets and produces their intersection as the\ncurrent set.</p>\n\n<h3>Intersect (Fuzzy)</h3>\n\n<p>When dealing with more than two sets, <code>intersect</code> has an option called <code>-min</code> that sets\nthe threshold for membership in the current set. This option is discussed in more detail\nin <a href=\"#/guide/command_app_multi\">Multi-Page Ext JS Apps</a>.</p>\n\n<p>For example,</p>\n\n<pre><code>sencha compile ... \\\n    intersect -min=2 -set page1,page2,page3 and \\\n    ...\n</code></pre>\n\n<p>This use of <code>intersect</code> produces in the current set all files that are found in 2 of the 3\nsets specified.</p>\n\n<h2 id='command_compiler-section-5'>Compiler Directives</h2>\n\n<p>In many situations, it is helpful to embed metadata in files that only the compiler will\npick up. To do this, the compiler recognizes special line comments as directives.</p>\n\n<p>The list of directives is:</p>\n\n<ul>\n<li><code>//@tag</code></li>\n<li><code>//@define</code></li>\n<li><code>//@require</code></li>\n</ul>\n\n\n<h3>Tagging</h3>\n\n<p>In an ideal world, a namespace would be sufficient to define a set of interest. Sometimes,\nhowever, a set can be quite arbitrary and even cross namespace boundaries. Rather than move\nthis issue to the command-line level, the compiler has the ability to track arbitrary tags\nin files.</p>\n\n<p>For example:</p>\n\n<pre><code>//@tag foo,bar\n</code></pre>\n\n<p>The above will assign the tags \"foo\" and \"bar\" to the file. These tags can be used in the\n<code>include</code>, <code>exclude</code> and <code>union</code> commands with their <code>-tag</code> option.</p>\n\n<h3>Dealing with \"Other\" JavaScript Files</h3>\n\n<p>In some cases, JavaScript files define things and require things that are not expressed in\nterms of <code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a></code> and <code>requires</code> or <code><a href=\"#!/api/Ext-method-require\" rel=\"Ext-method-require\" class=\"docClass\">Ext.require</a></code>. Using <code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a></code> you can still\nsay that a class <code>requires</code> such things and the dynamic loader will not complain so long\nas those things exist (if they do not exist, the loader will try to load them which will\nmost likely fail).</p>\n\n<p>To support arbitrary JavaScript approaches to defining and requiring types, the compiler\nalso provides these directives:</p>\n\n<pre><code>//@define Foo.bar.Thing\n//@requires Bar.foo.Stuff\n</code></pre>\n\n<p>These directives set up the same basic metadata in the compiler that tracks what file\ndefines a type and what types that file requires. In most ways, then, these directives\naccomplish the same thing as an <code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a></code> with <code>requires</code> property.</p>\n\n<p>Of course, you can use either of these directives in a file without using the other.</p>\n\n<h2 id='command_compiler-section-6'>Conditional Compilation</h2>\n\n<p>You may have seen in the SDK sources, code that looks like this:</p>\n\n<pre><code>foo: function () {\n    //&lt;debug&gt;\n    if (sometest) {\n        Ext.log.warn(\"Something is wrong...\");\n    }\n    //&lt;/debug&gt;\n\n    ...\n}\n</code></pre>\n\n<p>The idea here is that some code is very helpful in development, but too expensive to have\nin production. The above illustrates only one of the many conditional compilation directives\nsupported by the compiler, but it is also the most useful.</p>\n\n<p>IMPORTANT: The thing to be aware of when using conditional compilation is that unless you\nare always running compiled code, these directives are just comments and the conditional\ncode will be \"live\" during development.</p>\n\n<h3>The &lt;debug> directive</h3>\n\n<p>When compiling, by default, none of the preprocessor statements are examined. So in this\ncase, the result is development mode. If we switch on <code>-debug</code> we get a very similar result,\nbut with the preprocessor active. In fact, the only difference is that the preprocessor\ndirectives are removed.</p>\n\n<p>That is, this command:</p>\n\n<pre><code>sencha compile -classpath=... \\\n    -debug \\\n    ...\n</code></pre>\n\n<p>Will generate code like this for the above:</p>\n\n<pre><code>foo: function () {\n    if (sometest) {\n        Ext.log.warn(\"Something is wrong...\");\n    }\n\n    ...\n}\n</code></pre>\n\n<p>Whereas this command:</p>\n\n<pre><code>sencha compile -classpath=... \\\n    -debug=false \\\n    ...\n</code></pre>\n\n<p>Will generate code like this for the above:</p>\n\n<pre><code>foo: function () {\n    ...\n}\n</code></pre>\n\n<p>You can see that the \"if\" test and the log statement are both removed.</p>\n\n<h3>The &lt;if> directive - TODO</h3>\n\n<p>The most general directive is <code>if</code>. The <code>if</code> directive tests one or more configured options\nagainst the \"attributes\" of the directive and removes the code in the the block if any are\nfalse.</p>\n\n<p>For example:</p>\n\n<pre><code>//&lt;if debug&gt;\n//&lt;/if&gt;\n</code></pre>\n\n<p>This is equivalent to the <code>&lt;debug&gt;</code> directive.</p>\n\n<p>TODO</p>\n","title":"Sencha Compiler Reference"});