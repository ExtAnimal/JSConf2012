Ext.data.JsonP.command_compiler_meta({"guide":"<h1>Generating Metadata</h1>\n\n<p>The compiler's primary role is to read JavaScript code and produce concatenated (and\ncompressed) output files. In doing this, the compiler has to understand many things about\nthe code. It turns out that this metadata tracked by the compiler can have many other\nuses. To support these uses, the compiler can export and format this metadata in several\ndifferent ways.</p>\n\n<p><p><img src=\"guides/command_compiler_meta/../command/sencha-command-128.png\" alt=\"\"></p></p>\n\n<h2>Generating Output with <code>meta</code></h2>\n\n<p>One of the major new dimensions to using the compiler is the ability to export its meta-data\nin various formats. This feature is used to produce the <code>ext.js</code> \"bootstrap\" file which\ncontains various classes and then a block of meta-data about all of the files in the\nframework.</p>\n\n<p>There are several forms of meta-data that the compiler can export using the <code>meta</code> command:</p>\n\n<ul>\n<li>Class aliases</li>\n<li>Alternate class names</li>\n<li>Loader paths</li>\n<li>Filenames</li>\n</ul>\n\n\n<h3>Generating A Custom Bootstrap</h3>\n\n<p>The primary use for the <code>meta</code> command is to create your own \"bootstrap\" file. This file\nwill give the framework the same level of \"awareness\" of your application code that it has\nof the framework code itself.</p>\n\n<p>The simplest way to manage your bootstrap file is to store it along side your markup file.\nIf that cannot work for you, read on to see how to manage relative paths.</p>\n\n<p>If you have your markup file in a source folder in your classpath, you will need to tell\nthe compiler to ignore the bootstrap file. You can do this using the <code>-ignore</code> switch:</p>\n\n<pre><code>sencha compile -classpath=sdk/src,app -ignore bootstrap.js \\\n    ...\n</code></pre>\n\n<h3>Enabling Wildcard Support in <code>requires</code></h3>\n\n<p>If you look at the end of <code>ext-debug.js</code>, you will find that it contains these two function\ncalls:</p>\n\n<pre><code><a href=\"#!/api/Ext.ClassManager-method-addNameAlternateMappings\" rel=\"Ext.ClassManager-method-addNameAlternateMappings\" class=\"docClass\">Ext.ClassManager.addNameAlternateMappings</a>({\n    \"<a href=\"#!/api/Ext.draw.engine.ImageExporter\" rel=\"Ext.draw.engine.ImageExporter\" class=\"docClass\">Ext.draw.engine.ImageExporter</a>\": [],\n    \"<a href=\"#!/api/Ext.layout.component.Auto\" rel=\"Ext.layout.component.Auto\" class=\"docClass\">Ext.layout.component.Auto</a>\": [],\n    ...\n]);\n\n<a href=\"#!/api/Ext.ClassManager-method-addNameAliasMappings\" rel=\"Ext.ClassManager-method-addNameAliasMappings\" class=\"docClass\">Ext.ClassManager.addNameAliasMappings</a>({\n    \"<a href=\"#!/api/Ext.draw.engine.ImageExporter\" rel=\"Ext.draw.engine.ImageExporter\" class=\"docClass\">Ext.draw.engine.ImageExporter</a>\": [],\n    \"<a href=\"#!/api/Ext.layout.component.Auto\" rel=\"Ext.layout.component.Auto\" class=\"docClass\">Ext.layout.component.Auto</a>\": [\n        \"layout.autocomponent\"\n    ],\n    ...\n]);\n</code></pre>\n\n<p>It is the presence of these two pieces of meta-data that allow wildcards to be used in\n<code>requires</code> statements. That is:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('MyApp.App', {\n    requires: [\n        'Ext.grid.*'\n    ],\n    ...\n});\n</code></pre>\n\n<p>All that is required to use wildcards in your own code is to provide the same \"bootstrap\"\ndata for your app.</p>\n\n<p>This command will produce a file that does just that:</p>\n\n<pre><code>sencha compile -classpath=app \\\n    meta -alias -out bootstrap.js and \\\n    meta -alt -append -out bootstrap.js\n</code></pre>\n\n<p>The above command line tells the compiler to read in the source in the \"app\" folder and\ngenerate two pieces of meta-data. The second piece of meta-data is written to the same\noutput file as the first, but using the <code>-append</code> option to append to the file and not\nreplace it.</p>\n\n<p>Once you have the \"bootstrap.js\" file, change your page like so to add it to the\n<code>x-bootstrap</code> section:</p>\n\n<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;!-- &lt;x-compile&gt; --&gt;\n            &lt;!-- &lt;x-bootstrap&gt; --&gt;\n                &lt;script src=\"../sdk/ext-dev.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n\n                &lt;script src=\"bootstrap.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n            &lt;!-- &lt;/x-bootstrap&gt; --&gt;\n\n            &lt;script src=\"app/app.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n        &lt;!-- &lt;/x-compile&gt; --&gt;\n    &lt;/head&gt;\n    &lt;body&gt;&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Of course, the \"bootstrap.js\" file needs to be regenerated if you do any of the following:</p>\n\n<ul>\n<li>Add a class</li>\n<li>Remove a class</li>\n<li>Change class aliases</li>\n<li>Change class alternate names</li>\n</ul>\n\n\n<p>This rebuild of the bootstrap data can be handled in a variety of ways, but the fundamental\nquestion is whether or not to keep these files in source control, or require developers to\ngenerate them locally. Both approaches work and can be automated to some degree.</p>\n\n<h3>Exporting Loader Paths</h3>\n\n<p>In large applications it can be helpful to organize your namespace using multiple source\ntrees. In fact, Ext JS itself uses three source trees. This approach, however, has always\npresented problems for the dynamic loader and you had to configure loader paths by hand to\nwork around the issue.</p>\n\n<p>The compiler, however, has complete knowledge of class-to-file relationships given all of\nthe source in the classpath. And the <code>meta</code> command can export that data for use in your\napplication.</p>\n\n<p>If you are already sold on the above to create a \"bootstrap.js\", this data can be added by\nadding one more <code>meta</code> command (of course, the classpath will contain multiple folders in\nthis case):</p>\n\n<pre><code>sencha compile -classpath=src1,src2,src3 \\\n    meta -alias -out bootstrap.js and \\\n    meta -alt -append -out bootstrap.js and \\\n    meta -loader -append -out bootstrap.js\n</code></pre>\n\n<p>Now the \"bootstrap.js\" file solves both problems. With this approach, the following things\nwill also require you to rebuild \"bootstrap.js\":</p>\n\n<ul>\n<li>Rename a file or folder</li>\n<li>Reorganize the classpath</li>\n<li>Reorganize the content of any of the source trees</li>\n</ul>\n\n\n<h3>Resolving Relative Paths with <code>-base-path</code></h3>\n\n<p>For many good reasons, paths need to be relative. Whenever you deal with relative paths,\nhowever, you eventually need to wrestle with the problem of where those relative paths are\nbased.</p>\n\n<p>In the above examples we have \"cheated\" a bit and placed the \"bootstrap.js\" file next to\nthe markup file. This leverages the fact that the <code>meta</code> command defaults the base folder\nto the location of the output file.</p>\n\n<p>When this is not the case, you need to tell the <code>meta</code> command the base for determining\nrelative paths. Let's say we want to move the \"bootstrap.js\" file in to the \"build\" folder\n(perhaps because we are not keeping it in source control). Since our page is in the current\nfolder and our source is in the \"app\" folder, this will generate the proper relative paths:</p>\n\n<pre><code>sencha compile -classpath=src1,src2,src3 \\\n    meta -alias -out build/bootstrap.js and \\\n    meta -alt -append -out build/bootstrap.js and \\\n    meta -loader -append -base-path . -out build/bootstrap.js\n</code></pre>\n\n<p>Since the <code>-alias</code> and <code>-alt</code> modes do not deal in paths, the <code>-base-path</code> option is only\nneeded on the <code>-loader</code> use of the <code>meta</code> command.</p>\n\n<h3>Changing the Format</h3>\n\n<p>By default, the <code>meta</code> command exports meta-data in JSONP format using a function call\nwrapper appropriate for the type of meta-data requested. If a different function call is\ndesired or you want the data in JSON format, you can request this in the <code>meta</code> command.</p>\n\n<p>In the example below, the \"aliases.json\" file will contain the alias data in JSON format.\nYou cannot use <code>-append</code> in this case because JSON format requires a single, top-level\nobject or array.</p>\n\n<pre><code>sencha compile -classpath=src1,src2,src3 \\\n    meta -alias -json -out aliases.json\n</code></pre>\n\n<p>In this next example, we customize the JSONP wrapping by supplying the function to call:</p>\n\n<pre><code>sencha compile -classpath=src1,src2,src3 \\\n    meta -alias -jsonp Foo.bar.doAliases -out aliases.js\n</code></pre>\n\n<p>This form can work with <code>-append</code> because it produces JavaScript code. The output of the\nabove will look roughly like this:</p>\n\n<pre><code>Foo.bar.doAliases(\n    // ... the JSON data ...\n);\n</code></pre>\n\n<h3>Exporting Filenames</h3>\n\n<p>The final useful form of meta-data supported by the <code>meta</code> command is filename data. That\nis, the list of a files in the proper, dependency order. In many ways this is the same as\nthe other meta data forms in that this data can be exported in JSON or JSONP format, and\ncan be combined using <code>-append</code>.</p>\n\n<p>The first difference with <code>-filenames</code> is that the default format is text. To produce JSON\nor JSONP, you must specify one of the <code>-json</code> or <code>-jsonp</code> options.</p>\n\n<p>In the default mode of text, the filenames are written as lines of text, one filename per\nline. The following command will create \"filenames.txt\":</p>\n\n<pre><code>sencha compile -classpath=src1,src2,src3 \\\n    meta -filenames -out filenames.txt\n</code></pre>\n\n<p>If we want, we can decorate each line of the file using the <code>-tpl</code> option. Because of the\nspecial characters needed for this example, we use a response file to hold the template.</p>\n\n<p>We put this in \"template.txt\":</p>\n\n<pre><code>&lt;script src=\"{0}\" type=\"text/javascript\"&gt;&lt;/script&gt;\n</code></pre>\n\n<p>Then run the following command.</p>\n\n<pre><code>sencha compile -classpath=src1,src2,src3 \\\n    meta -filenames -tpl @template.txt -out filenames.txt\n</code></pre>\n\n<p>We know have a chunk of markup that will script-tag in all of the files in their correct\norder.</p>\n","title":"Generating Metadata"});