Ext.data.JsonP.command_app_multi({"guide":"<h1>Developing Multi-Page Ext JS Apps</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/command_app_multi-section-1'>Large Applications</a></li>\n<li><a href='#!/guide/command_app_multi-section-2'>The Application</a></li>\n<li><a href='#!/guide/command_app_multi-section-3'>Caching Shared Code</a></li>\n<li><a href='#!/guide/command_app_multi-section-4'>Beyond Two Pages</a></li>\n</ol>\n</div>\n\n<p><p><img src=\"guides/command_app_multi/../command/sencha-command-128.png\" alt=\"\"></p></p>\n\n<h2 id='command_app_multi-section-1'>Large Applications</h2>\n\n<p>Many Ext JS applications grow to a point where they require multiple pages. For these\napplications, there is typically a desire to share code between these pages. This code can\nconsist of data models, views, controllers, custom components and general utilities to\nname a just few possibilities.</p>\n\n<p>In some cases, these applications can be viewed as independent, single-page \"applications\".\nWhether this is the approach you settle on or not, the basic processes for building these\nlarger applications start the same as for single-page applications. Please refer to\n<a href=\"#/guide/command_app_single\">Developing Single-Page Ext JS Apps</a>.</p>\n\n<h3>Terminology Check</h3>\n\n<p>In Ext JS, pages that use the MVC architecture have a call to <code><a href=\"#!/api/Ext-method-application\" rel=\"Ext-method-application\" class=\"docClass\">Ext.application</a></code> at the top\nof their code tree. This can be confusing because the framework uses the term \"application\"\nto describe each page. In single-page applications, these terms are interchangeable but\nclearly this is not the case when your application has multiple pages.</p>\n\n<p>In pages built outside of the MVC architecture, the top-level of each page is completely\narbitrary, but typically starts with a function passed to <code><a href=\"#!/api/Ext-method-onReady\" rel=\"Ext-method-onReady\" class=\"docClass\">Ext.onReady</a></code>.</p>\n\n<p>In all cases, each page will have some form of markup file that pulls all of these pieces\ntogether. So to avoid confusion, this guide does not use the term \"application\" in the same\nway as MVC. That is, an MVC \"application\" is just a \"page\" as would be the case without\nMVC.</p>\n\n<h2 id='command_app_multi-section-2'>The Application</h2>\n\n<p>To illustrate the relevant commands, lets assume that we have a two page application with\nthe following folder structure:</p>\n\n<pre><code>build/              # The folder where build output is placed.\ncommon/             # Things common to all pages of the application.\n    src/            # Shared JavaScript code for all pages.\next/                # The framework distribution.\n    src/            # The framework source tree.\npage1/\n    index.php       # The markup file for page 1.\n    src/            # Folder containing JavaScript code unique to page 1.\npage2/\n    index.php       # The markup file for page 2.\n    src/            # Folder containing JavaScript code unique to page 2.\n</code></pre>\n\n<p>This example could be extended to cover many more pages but that would only make it harder\nto follow the example commands. There are some features, however, that only apply to\napplications with three or more pages so we will expand the example to illustrate that\nusage.</p>\n\n<h2 id='command_app_multi-section-3'>Caching Shared Code</h2>\n\n<p>If users of the application tend to visit more than one page, it may be helpful to split\nup the code such that common code is in a shared file while page-specific code is isolated\nto a second script file.</p>\n\n<p>In terms of set operations this is called a set \"intersection\". That is to say, we want to\ntake the files in the intersection of the two sets of files needed by each page and generate\na file with just those classes.</p>\n\n<p>The following command will do precisely that. Don't worry, we will walk through what each\nof these pieces accomplishes.</p>\n\n<pre><code>sencha compile -classpath=ext/src,common/src,page1/src,page2/src \\\n    page -name=page1 -in page1/index.php -out build/page1/index.php \\\n         -scripts ../common.js and \\\n    page -name=page2 -in page2/index.php -out build/page2/index.php \\\n         -scripts ../common.js and \\\n    intersect -set page1,page2 and \\\n    save common and \\\n    concat +yui build/common.js and \\\n    restore page1 and \\\n    exclude -set common and \\\n    concat +yui build/page1/all-classes.js and \\\n    restore page2 and \\\n    exclude -set common and \\\n    concat +yui build/page2/all-classes.js\n</code></pre>\n\n<p>The first thing is to create the <code>compile</code> context and tell it the <code>classpath</code> for all of\nthe source code folders:</p>\n\n<pre><code>sencha compile -classpath=ext/src,common/src,page1/src,page2/src \\\n</code></pre>\n\n<p>Then we use two <code>page</code> commands to include the source from each page as well as generate\nthe appropriate output pages in the \"build\" folder. Each <code>page</code> command produces a set\nof files containing exactly the files needed by that page. These sets are given the names\n\"page1\" and \"page2\". Finally, each generated output page will get an extra <code>script</code> tag\nwhose <code>src</code> attribute is \"../common.js\".</p>\n\n<pre><code>    page -name=page1 -in page1/index.php -out build/page1/index.php \\\n         -scripts ../common.js and \\\n    page -name=page2 -in page2/index.php -out build/page2/index.php \\\n         -scripts ../common.js and \\\n</code></pre>\n\n<p>Now that all of the files needed by each page are recorded in two sets, we use <code>intersect</code>\nto determine the files needed by both pages. Only these files will be included in the\ncurrent set.</p>\n\n<pre><code>    intersect -set page1,page2 and \\\n</code></pre>\n\n<p>We use <code>save</code> to record the current set of files (the result of the intersection). These\nare the files we will be putting in \"common.js\". The name for the new set is \"common\".</p>\n\n<pre><code>    save common and \\\n</code></pre>\n\n<p>Then we use <code>concat</code> to combine the files and produce \"build/common.js\" (also compressing\nthe file using `+yui' to engage the YUI Compressor).</p>\n\n<pre><code>    concat +yui build/common.js and \\\n</code></pre>\n\n<p>Now we need to produce the \"all-classes.js\" for each page, so we use <code>restore</code> to make\nthe current set equal to the previously saved set for the page:</p>\n\n<pre><code>    restore page1 and \\\n</code></pre>\n\n<p>Then we remove from this set all of the files that we just generated in \"common.js\":</p>\n\n<pre><code>    exclude -set common and \\\n</code></pre>\n\n<p>And then use <code>concat</code> again to produce \"all-classes.js\" for the page:</p>\n\n<pre><code>    concat +yui build/page1/all-classes.js and \\\n</code></pre>\n\n<p>We repeat the last few steps again for page2:</p>\n\n<pre><code>    restore page2 and \\\n    exclude -set common and \\\n    concat +yui build/page2/all-classes.js\n</code></pre>\n\n<h3>Alternative Strategy - Sharing A Framework Subset</h3>\n\n<p>A different way to partition shared code would be to isolate all of the framework code\nneeded by the application and produce a file similar to \"ext-all.js\" but only containing\nthose classes needed by some part of the application. This approach might load more of the\nframework than needed by each page, but the benefits of the browser cache could easily\nmake up for this increase.</p>\n\n<p>The following command contains only a slight adjustment to the above:</p>\n\n<pre><code>sencha compile -classpath=ext/src,common/src,page1/src,page2/src \\\n    page -name=page1 -in page1/index.php -out build/page1/index.php \\\n         -scripts ../common.js and \\\n    page -name=page2 -in page2/index.php -out build/page2/index.php \\\n         -scripts ../common.js and \\\n    union -set page1,page2 and \\\n    exclude +not -namespace Ext and \\\n    save common and \\\n    concat +yui build/common.js and \\\n    restore page1 and \\\n    exclude -set common and \\\n    concat +yui build/page1/all-classes.js and \\\n    restore page2 and \\\n    exclude -set common and \\\n    concat +yui build/page2/all-classes.js\n</code></pre>\n\n<p>The difference between this command and the previous command is in how the \"common\" set is\ncalculated.</p>\n\n<pre><code>    union -set page1,page2 and \\\n    exclude +not -namespace Ext and \\\n</code></pre>\n\n<p>In this case the <code>union</code> command is used to include all files used by either page. This\nset is then reduced using the <code>exclude</code> command to remove all classes that are not in the\nExt namespace. This will leave only the framework code that is needed by either page in\nthe current set.</p>\n\n<p>The remainder of the command above and below these two lines is the same as before.</p>\n\n<h2 id='command_app_multi-section-4'>Beyond Two Pages</h2>\n\n<p>Applications with more than two pages can be managed as an extension of a two-page\napplication as discussed above. Just add extra <code>page</code> commands (one for each page) and\nextra set operations to produce the appropriate \"all-classes.js\" file for each page.</p>\n\n<p>There are interesting possibilities for code sharing, however, amongst the multiple pages\nthat may be worth considering. To explore some of these possibilities, for the moment,\nconsider a 5 page application structured in the same basic way.</p>\n\n<p>It may be that the common set of files produced by the intersection of all pages is quite\nsmall. This will force code that is not used by all pages out of \"common.js\" and in to\neach page's \"all-classes.js\". One strategy for dealing with this is to manually divide up\nsimilar pages and treat the application as multiple, independent, multi-page applications.</p>\n\n<p>Another, simpler, way would be to use a \"fuzzy intersection\": an operation the selects all\nclasses used by a specified minimum number of pages.</p>\n\n<pre><code>sencha compile -classpath=ext/src,common/src,page1/src,page2/src \\\n    page -name=page1 -in page1/index.php -out build/page1/index.php \\\n         -scripts ../common.js and \\\n    page -name=page2 -in page2/index.php -out build/page2/index.php \\\n         -scripts ../common.js and \\\n    page -name=page2 -in page3/index.php -out build/page3/index.php \\\n         -scripts ../common.js and \\\n    page -name=page2 -in page4/index.php -out build/page4/index.php \\\n         -scripts ../common.js and \\\n    page -name=page2 -in page5/index.php -out build/page5/index.php \\\n         -scripts ../common.js and \\\n    intersect -min=3 -set page1,page2,page3,page4,page5 and \\\n    save common and \\\n    concat +yui build/common.js and \\\n    restore page1 and \\\n    exclude -set common and \\\n    concat +yui build/page1/all-classes.js and \\\n    restore page2 and \\\n    exclude -set common and \\\n    concat +yui build/page2/all-classes.js and \\\n    restore page3 and \\\n    exclude -set common and \\\n    concat +yui build/page3/all-classes.js and \\\n    restore page4 and \\\n    exclude -set common and \\\n    concat +yui build/page4/all-classes.js and \\\n    restore page5 and \\\n    exclude -set common and \\\n    concat +yui build/page5/all-classes.js\n</code></pre>\n\n<p>Other than the three additional <code>page</code> commands as well as three stanzas of <code>restore</code>,\n<code>exclude</code> and <code>concat</code>, the above command only changed from the original intersection in\nthis one way:</p>\n\n<pre><code>    intersect -min=3 -set page1,page2,page3,page4,page5 and \\\n</code></pre>\n\n<p>The <code>-min</code> switch activated the fuzzy intersection method. By default, <code>intersect</code> selects\nclasses used by 100% of the specified sets or, in this case, all 5 sets. With <code>-min</code> you\ncan override this threshold. By specifying <code>-min=3</code> we are saying to include in the current\nset any class used by at least 3 sets (or 60%).</p>\n","title":"Developing Multi-Page Ext JS Apps"});